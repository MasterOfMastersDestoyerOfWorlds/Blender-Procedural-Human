Computational Aesthetics: A Fresnel-Based Architecture for Procedural Painterly Shading1. Executive SummaryThis research report presents a comprehensive technical architecture for the development of a non-photorealistic rendering (NPR) solution aimed at emulating the distinctive "oil painting" aesthetic observed in digital art direction, specifically referencing the visual style of Dishonored. The primary objective is to engineer a shader that generates "planar faces of similar colors" and "black distortions simulating brush stroke ends," strictly utilizing Edge Detection and the Fresnel Effect as the governing mechanisms, while explicitly rejecting Voronoi-based cellular tessellation.The analysis begins by deconstructing the artistic requirements, identifying that the desired aesthetic relies on two fundamental abstractions: the geometric simplification of form (planarization) and the simulation of physical media application (stroke distortion). Traditional NPR methods often rely on Voronoi patterns to create faceted surfaces; however, this report demonstrates that Voronoi tessellation creates isotropic, topology-agnostic cells that fail to respect the underlying sculptural anatomy of 3D models. Consequently, a vector-based approach utilizing surface normal quantization and view-dependent Fresnel gradients is proposed as a superior alternative for generating anatomically correct planar faces.To achieve the "black distortions" characteristic of dry-brush techniques, the report details a signal processing strategy involving Domain Warping and Thresholded Edge Detection. By perturbing the input vectors of the Fresnel calculation with high-frequency, anisotropic noise, we can mathematically simulate the unpredictable "drag" and "breakup" of a bristle brush at the silhouette and internal terminators of a model. This method transforms the smooth, mathematical precision of standard 3D rendering into the organic, chaotic topology of hand-painted media.The following sections provide an exhaustive theoretical foundation, mathematical derivation, and practical implementation guide for this shading architecture, adaptable to modern render engines such as Blender (Cycles/Eevee), Unity (Shader Graph), and Unreal Engine (Material Editor).2. Artistic and Theoretical FrameworkTo successfully engineer a procedural shader that mimics a specific art style, one must first deconstruct the visual language of that style into component rules that can be translated into mathematical operations. The user query highlights a desire for the Dishonored aesthetic—a style characterized not by cel-shading or distinct "toon" outlines, but by a sculptural, illustrative approach to texture and lighting.2.1 Deconstructing the Dishonored AestheticThe visual identity of Dishonored, as analyzed in various technical breakdowns , is rooted in the traditions of classical oil painting, specifically the alla prima (wet-on-wet) technique. In this style, artists do not blend every transition to a smooth gradient. Instead, they "block in" forms using distinct planes of color. A curved surface, such as a cheekbone or a worn stone wall, is interpreted as a series of flat slabs—a "highlight plane," a "mid-tone plane," and a "shadow plane".Crucially, the texture work in Dishonored involves "hand-painted texture maps that mimic oil paintings" and "exaggerated angular character sculpts". The shader is not merely a filter applied over a realistic model; it acts as a surrogate for the artist's brush, interpreting the geometry. The lighting behaves realistically but is rendered through a stylized lens that emphasizes silhouette and volume over high-frequency surface detail.Technical analyses of the game's production reveal that environment artists utilized "slope blur" nodes in Substance Designer to create "chipped" edges and worn surfaces. Slope blur works by smearing a gradient based on a noise input—a technique we will emulate procedurally using vector distortion. This confirms that the "black distortions" requested by the user are not random noise but are structurally related to the edges and wear points of the geometry.2.2 The Limitations of Voronoi TessellationThe user explicitely requests a solution that avoids Voronoi patterns. It is vital to understand why this constraint improves the final result.Voronoi patterns are generated by scattering seed points in 3D space and calculating the distance from every pixel to the nearest seed. This creates a cellular structure often used to simulate cracked mud, scales, or hammered metal. However, Voronoi patterns suffer from two critical flaws when applied to painterly shading:Topology Agnosticism: Voronoi cells are generated in space, independent of the model's curvature or features. A Voronoi cell might straddle the sharp edge of a nose and a cheek, effectively "painting over" the facial feature rather than defining it.Isotropy: Standard Voronoi cells tend to be roughly circular or hexagonal. Brush strokes, however, are highly anisotropic—they have directionality, length, and flow.By rejecting Voronoi, we are forced to use Surface Analysis (normals and curvature) to define our planes. This ensures that every "planar face" generated by the shader directly corresponds to the actual shape of the 3D model, resulting in a look that resembles a "carved" or "sculpted" painting rather than a procedural overlay.2.3 The Physics of "Similar Colors" and QuantizationThe user requests "planar faces of similar colors." In color theory, this refers to analogous color schemes or monochromatic value studies.In a standard physically based rendering (PBR) workflow, light interaction results in a continuous gradient of values from 0 (shadow) to 1 (highlight). To achieve "planar faces," this continuous gradient must be quantized. Quantization is the process of mapping a large set of input values to a smaller set of output values—rounding the smooth curve into a staircase.If we map these steps to colors that are close in hue (e.g., a deep indigo, a desaturated slate, and a pale blue-grey), we achieve the "similar colors" requirement. The visual result is a surface that appears to be constructed of distinct patches of pigment, unified by a cohesive lighting environment.3. Mathematical Foundations: Vector Calculus and RadiometryThe proposed solution relies heavily on vector math, specifically the manipulation of surface normals and the calculation of the Fresnel term. A rigorous understanding of these mechanics is necessary to control the "Edge Detection" and "Distortion" behaviors effectively.3.1 The Surface Normal Vector ($\vec{N}$)The normal vector $\vec{N}$ is a unit vector perpendicular to the surface at any given point. In 3D graphics, we deal with two types of normals:Geometric Normal: The true perpendicular of the polygon face. This creates the "flat shaded" or "low poly" look where every polygon is visible.Smooth/Interpolated Normal: The normal vector interpolated between vertices across the face. This creates the illusion of smooth curvature on low-poly geometry.To create the "planar" look on a smooth mesh without altering the geometry, we must mathematically manipulate the Smooth Normal to behave more like a Geometric Normal, or a stylized version thereof. This involves Stepped Quantization of the normal's components ($x, y, z$).3.2 The View Vector ($\vec{V}$)The view vector $\vec{V}$ represents the direction from the camera (or eye) to the point being shaded. Normalizing this vector ensures it has a length of 1, allowing for accurate dot product calculations.3.3 The Fresnel Equations and ApproximationThe Fresnel effect describes the phenomenon where a surface becomes more reflective as the angle of incidence becomes more grazing (parallel to the surface). In computer graphics, this is typically approximated using Schlick's approximation for performance.The fundamental operation driving our shader is the Dot Product of the Normal and View vectors:$$\cos\theta = \vec{N} \cdot \vec{V}$$If $\vec{N} \cdot \vec{V} = 1$: The surface is facing the camera directly (Center).If $\vec{N} \cdot \vec{V} = 0$: The surface is perpendicular to the camera (Edge/Silhouette).The "Fresnel Term" or "Facing Ratio" is derived from this relationship. In Blender's Layer Weight node, the "Facing" output is a linear representation ($1 - (\vec{N} \cdot \vec{V})$), while the "Fresnel" output applies an exponential power to simulate dielectric reflectivity.For our purposes—creating planar faces—the linear Facing ratio is often superior because it provides a uniform gradient that can be quantized evenly. The exponential Fresnel is superior for Edge Detection, as it isolates the very rim of the object more aggressively.3.4 Vector Distortion (Domain Warping)To simulate "black distortions" and "brush strokes," we cannot simply overlay a 2D noise texture. We must distort the coordinate system itself.Let $P$ be the position of a point on the surface. A standard texture lookup is $T(P)$.Domain warping involves adding a noise vector $\vec{\eta}$ to $P$ before the lookup:$$T'(P) = T(P + \vec{\eta}(P))$$In our shader, we apply this distortion to the Normal Vector before calculating the Fresnel term.$$\text{Fresnel}_{\text{distorted}} = \text{Fresnel}(\vec{N} + \text{Noise}(\vec{P}), \vec{V})$$Because the Normal vector is perturbed by noise, the resulting Fresnel calculation "thinks" the surface is facing different directions at high frequencies. This causes the smooth "rim light" effect of the Fresnel to shatter into jagged, noisy fragments—perfectly simulating the broken edges of a dry brush stroke.4. Architecture I: Planar Quantization (The "Baseline Mechanism")The first major component of the shader addresses the requirement for "planar faces of similar colors" using "Fresnel as the baseline mechanism." This section details the logic of converting smooth surface data into faceted, painterly planes.4.1 The Failure of Standard Toon ShadingStandard toon shading (Cel Shading) typically uses the dot product of the Normal and a Light Vector ($\vec{L}$) to create stepped lighting (Diffuse Ramp). While effective for anime styles, it depends entirely on the light source position. If the light moves, the shadows slide across the surface smoothly.The "Dishonored" style requires the surface itself to look faceted, regardless of lighting. Therefore, we prioritize View-Dependent quantization (Fresnel) combined with Normal-Dependent quantization. This ensures the planes feel like physical ridges on the object, not just shadows.4.2 Technique A: The Stepped Fresnel RampThis method uses the Fresnel gradient to define concentric "shells" of color, simulating the way a painter might lighten the paint mixture as they move from the edge of a form to its center.Implementation Logic:Input: Layer Weight Node. Use the Facing output for a linear 0-1 gradient.Quantization: Feed this gradient into a Color Ramp Node.Interpolation Mode: Set to Constant. This is the critical step. It disables the smooth blending between colors, forcing the gradient to snap from one color to the next.Stops Definition:0.0 - 0.4 (Edge): Dark Tone (e.g., Cool Dark Grey).0.4 - 0.7 (Mid): Mid Tone (e.g., Neutral Grey).0.7 - 1.0 (Center): Highlight (e.g., Warm White).Result: The object appears to be painted with three distinct values. Because the Fresnel effect is view-dependent, these "planes" will shift as the camera rotates, creating a "shimmering" effect similar to how specular highlights move across a faceted surface.4.3 Technique B: Normal Vector Quantization (The "Crystal" Effect)To create a more rigid, "carved" look that mimics the low-poly/sculpted aesthetic of Dishonored characters, we can quantize the normal vector before it is used for any calculation.Mathematical Operation:We separate the Normal Vector into its scalar components ($x, y, z$). We then apply a stepping function:$$x' = \frac{\text{floor}(x \cdot n)}{n}$$where $n$ is the number of steps (density).Node Network:Input: Geometry Node (Normal).Separate XYZ: Split the vector.Math (Snap) or Math (Round): Apply to each channel independently. A "Snap" increment of 0.2 will create 5 distinct steps per axis.Combine XYZ: Reassemble the vector.Usage: Use this new "Stepped Normal" as the input for the Fresnel or Layer Weight node.Visual Outcome:
The smooth gradient of the Fresnel effect is replaced by a jagged, crystalline pattern. When applied to the color ramp, this creates square/rectangular planes of color that look like chisel marks. This fulfills the "planar faces" requirement without using Voronoi logic, relying purely on the vector properties of the mesh itself.4.4 Color Strategy: Analogous HarmonyThe user specifies "similar colors." To implement this procedurally:Base Color: Choose a primary hue (e.g., Teal).Hue Variation: Use the quantized Fresnel value to slightly shift the Hue (e.g., +/- 0.05).Center planes (facing camera) shift towards Yellow (warmer).Edge planes (grazing angle) shift towards Blue (cooler).Value/Saturation: Use the quantization primarily to drive Value (Brightness) and Saturation.Shadows should be lower value, higher saturation (rich paint).Highlights should be higher value, lower saturation (mixed with white).This approach creates a "monochromatic" or "analogous" look that unifies the object, mimicking the limited palette of a traditional painter.5. Architecture II: The Distortion Engine (Edge Detection & Brush Strokes)The second critical requirement is "black distortions simulating brush stroke ends." This requires a sophisticated approach to Edge Detection and Signal Processing. We must generate a mask that identifies edges and then breaks them up in a way that resembles physical bristles.5.1 Edge Detection via Fresnel InversionWhile standard edge detection (Sobel) looks at pixel contrast, Fresnel-based edge detection looks at surface geometry.Logic: As established, the Fresnel value approaches 1.0 at the grazing angles (the edges of the 3D form relative to the camera).Thresholding: By using a Math (Greater Than) node on the Fresnel output, we can isolate the exact rim of the object.If Fresnel > 0.6 -> Output 1 (White Edge)Else -> Output 0 (Black Center)Inversion: We invert this mask to get black edges on a white background. However, a perfect Fresnel edge looks like a plastic outline. It needs to be "broken".5.2 The "Brush Stroke" Simulation (Anisotropic Noise)To make the edge look like a brush stroke, we need to introduce Noise that has specific characteristics:High Frequency: It must be detailed enough to look like bristles.Anisotropy (Directionality): Brush strokes are long and thin. Isotropic noise (like clouds) looks like dirt, not paint.Implementing Directional Noise:Texture Coordinate: Use Object Coordinates. This ensures the brush strokes "stick" to the model and don't slide around like a screen projection.Mapping Transformation: This is the key step. We must stretch the coordinate space.Scale X: 1.0Scale Y: 0.05 (Stretches the texture vertically along the Y axis).Scale Z: 1.0Noise Texture: Apply this stretched coordinate to a Noise Texture (Detail: 15.0, Roughness: 0.7).The result is a texture that looks like "streaks" or "rain"—mimicking the bristles of a brush.5.3 Domain Warping: The "Black Distortion" MechanismNow we combine the Edge Detection with the Directional Noise to create the "Black Distortions."The "Slope Blur" Emulation:Instead of simply multiplying the noise over the edge, we use the noise to distort the edge detection itself.Input: Geometry Normal.Distortion: Add the Directional Noise vector to the Normal Vector.Distorted Normal = Normal + (Directional Noise * Strength)Edge Detection: Feed this Distorted Normal into the Fresnel node.Result: The Fresnel calculation tries to find the edge of the object. However, because the normal vector is being pushed and pulled by the streak noise, the "edge" mathematical definition becomes jagged. The rim light "spikes" inward along the noise streaks.When this result is thresholded (clamped to black and white), the smooth edge of the object turns into a series of ragged, tapering lines. These are the "brush stroke ends" requested by the user. They appear to "grow" from the edge of the object inwards, simulating the way a painter might drag a dry brush from the background onto the form.5.4 Simulating "Dry Brush" Alpha ErosionTo further refine the look, we can simulate the "running out of paint" effect.Secondary Noise: Create a second, larger-scale noise texture (low frequency).Subtraction: Subtract this secondary noise from the Distorted Edge Mask.Effect: This breaks up the continuous lines of the brush strokes, creating gaps and "islands" of opacity. This mimics the texture of canvas showing through where the paint application was too thin.6. Detailed Implementation StrategyThe following section provides a granular, step-by-step guide to building this node network. While terminology borrows from Blender (Shader Nodes), the logic is universal to any graph-based shader system (Unity Shader Graph, Unreal Material Editor).6.1 Phase 1: The Planar CoreNode 1: Texture Coordinate (Object Output).Node 2: Mapping (No scale change).Node 3: Noise Texture (Scale 2.0, Detail 0.0) -> Coordinate Jitter.Node 4: MixRGB (Mix Object Coords with Noise, Fac 0.02).Purpose: Adds a global "wobble" to the entire object, preventing perfectly straight lines.Node 5: Layer Weight (Input: Geometry Normal).Node 6: Color Ramp (Input: Facing Output).Settings: Constant Interpolation.Stops: 0.0 (Dark Color), 0.5 (Mid Color), 0.8 (Light Color).Node 7: Diffuse BSDF (Color Input from Ramp).6.2 Phase 2: The Edge Distortion GeneratorNode 8: Texture Coordinate (Object).Node 9: Mapping (Scale: X=1, Y=20, Z=1). Crucial for anisotropy.Node 10: Noise Texture (Input: Mapped Vector).Settings: Scale 50.0, Detail 10.0, Roughness 0.8.Output: Fac.Node 11: MixRGB (Type: Linear Light).Input 1: Geometry Normal.Input 2: Noise Fac (from Node 10).Fac: 0.5 (Controls distortion strength).Node 12: Fresnel (Input: Normal from Node 11).IOR: 1.45.Node 13: Math (Greater Than).Threshold: 0.6.Output: Binary Mask (Black edges, White center).6.3 Phase 3: Integration and CompositionNode 14: Mix Shader.Shader 1: A simple Black Diffuse BSDF (The "Ink").Shader 2: The Planar Diffuse BSDF (From Phase 1).Factor: The Edge Mask (From Phase 2, Node 13).Refinement: To ensure the black lines appear on top of the color, the logic is typically: Mix(Ink, Color, Mask). If the mask is 1 at the center and 0 at the edge, use the mask to drive the mix.6.4 Table: Parameter Control and Artistic EffectThe following table summarizes how specific parameters in this architecture allow for artistic control over the painterly look.ParameterNode LocationEffect on VisualsQuantization StepsPhase 1: Color RampControls the number of "planes." Fewer stops = simpler, more abstract look. More stops = smoother, more realistic look.Noise Scale YPhase 2: MappingControls the "Length" of the brush bristles. Higher values (e.g., 50) create long, streaky dry-brush effects. Lower values create stippling.Distortion StrengthPhase 2: MixRGB (Normal)Controls the "Messiness" of the edges. Low values = clean, straight edges. High values = chaotic, expressive strokes.Fresnel ThresholdPhase 2: Math (>)Controls the "Thickness" of the outline. Higher threshold = thinner lines. Lower threshold = thick, heavy inking.Vector SnapOptional (Pre-Fresnel)Controls the "Carved" look. Snapping normal vectors makes the planes look rigid and crystalline (Dishonored style).7. Comparative Analysis: Fresnel vs. VoronoiA critical requirement of this research was to avoid Voronoi patterns. It is instructive to compare the two approaches to validate why the Fresnel/Edge method is superior for this specific request.FeatureVoronoi ApproachFresnel/Edge Approach (Proposed)Geometry SensitivityLow. Patterns are projected onto the surface. Cells cut across nose/eyes arbitrarily.High. Planes are derived from surface normals. Shapes respect the anatomy of the model.DirectionalityIsotropic. Cells are generally round or polygonal with no inherent direction.Anisotropic. Distortions can be aligned to tangent or view vectors, simulating brush flow.Edge QualityGeometric. Cell borders are straight lines.Organic. Edges are ragged, tapered, and fractal, mimicking physical paint interaction.Lighting IntegrationPoor. Voronoi is usually a texture overlay independent of lighting.Native. The "planes" are created by the lighting interaction (Fresnel), so they react naturally to view angle.The comparative analysis confirms that while Voronoi is excellent for generating static cellular textures (cracked earth, hammered copper), it fails to capture the dynamic, view-dependent simplification required for a painterly shader. The Fresnel-based approach essentially creates a "topographical map" of the object relative to the viewer, which aligns much closer to how a human artist analyzes form.8. Integration of Research MaterialThe architecture proposed herein directly synthesizes the disparate techniques found in the research snippets:Slope Blur & Edge Wear: The "Distorted Normal -> Fresnel" technique (Phase 2) is the mathematical equivalent of the "Slope Blur" node used in Substance Designer for Dishonored textures. It effectively "chips" the edge of the Fresnel rim using noise.Oil Paint Aesthetics: The rejection of high-frequency detail in favor of "planar faces of similar colors" aligns with the Dishonored art direction analysis, which prioritizes "hand painted texture maps that mimic oil paintings" and "exaggerated angular character sculpts".Brush Stroke Simulation: The use of stretched, directional noise to modulate opacity draws on techniques for "procedural brush strokes" and "dry brush" effects discussed in Blender community threads.Planarization: The use of stepped Fresnel ramps satisfies the need to create "planar faces" without actual geometry alteration, effectively simulating the "carved" look of the game's characters.9. ConclusionThe "Painterly Planar Shader" requested can be robustly implemented without Voronoi tessellation by leveraging the Fresnel Effect as a topographical analyzer and Domain Warping as a stroke simulator.Mechanism 1 (Planar Faces): By quantizing the gradient of the view-dependent Fresnel term, we effectively segment the mesh into discrete lighting zones. This creates the illusion of "planar faces" that respect the model's anatomy and lighting environment.Mechanism 2 (Black Distortions): By injecting high-frequency, anisotropic noise into the normal vector before the Fresnel calculation, we disrupt the edge detection logic. This causes the shader to render the object's silhouette and internal terminators as ragged, "dry-brush" lines rather than smooth vectors.Mechanism 3 (Similar Colors): By utilizing the quantized Fresnel zones to drive subtle hue shifts within an analogous color palette, we achieve the cohesive, illustrative look of a master study oil painting.This architecture creates a shader that is not merely a static filter, but a dynamic, geometry-aware material that interprets the underlying 3D form through the lens of traditional art techniques. It mimics not just the look of a painting, but the process—blocking in planes of color and refining edges with expressive, imperfect strokes.9.1 Future Outlook and OptimizationWhile this procedural approach offers infinite resolution and dynamic adaptability, it is computationally heavier than standard texture mapping due to the multiple noise lookups and vector math operations per pixel.Optimization: For real-time applications (games), the "Edge Distortion" and "Planar Maps" can be baked into static Albedo and Emission textures using the UV coordinates of the model.Animation: For animated characters, the "Object Coordinate" system ensures the brush strokes follow the limbs, avoiding the "shower door effect" (where texture stays static on screen while the character moves behind it).Stylistic Extension: Further refinement could involve using the Curvature of the mesh (via Pointiness or Bevel nodes) to add "cavity dirt" or "edge highlights" , further enhancing the Dishonored "worn world" aesthetic.This report provides a complete theoretical and practical roadmap for implementing the desired shader, satisfying all user constraints through rigorous vector mathematics and artistic intuition.