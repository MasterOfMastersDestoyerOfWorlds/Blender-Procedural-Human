Optimal Extraction of Geodesic Spines from 2D Shapes Using Depth-Weighted Medialness and Global Pathfinding1. Introduction to Morphological SkeletonizationThe computational extraction of a one-dimensional "spine" or centerline from a two-dimensional object representation serves as a cornerstone in diverse fields ranging from medical image analysis and robotic path planning to geological channel mapping and biological phenotyping. While the fundamental problem of skeletonization—reducing a shape to a stick-figure representation that preserves topology—is well-studied for binary shapes, the integration of continuous depth information (or height maps) introduces a higher order of complexity and opportunity. The availability of a depth map, correlated with the object's spatial extent, allows for the reconstruction of a "2.5D" skeleton that is significantly more robust to boundary noise and shape irregularities than skeletons derived from binary silhouettes alone.This report addresses the specific challenge of automatically identifying the "spine of the curve"—defined as the singular, connected path linking the geometric "tip" and "tail" of an object through its morphological center. The user has proposed a heuristic approach rooted in local gradient ascent: initiating a search at a boundary location with minimal depth and employing an A* algorithm to traverse the path of highest depth gradient. While this proposal intuits the relationship between depth intensity and skeletal likelihood, it relies on local optimization principles that are prone to failure in complex, non-convex, or noisy topographies.The analysis presented herein establishes that the "correct" and mathematically robust solution lies in the domain of Global Geodesic Pathfinding on a Riemannian manifold. By fusing the Euclidean Distance Transform (EDT) derived from the object's outline with the explicit Depth Map, one can construct a scalar field known as "medialness." The spine is then rigorously defined as the global minimum cost path (geodesic) connecting the shape's geodesic extrema. This framework, leveraging the Fast Marching Method (FMM) and Double Sweep algorithms, guarantees connectivity, smoothness, and centeredness, overcoming the limitations of greedy gradient-based heuristics.1.1 The Definition of the SpineIn the context of shape analysis, the term "spine" typically refers to a subset of the Medial Axis or Curve Skeleton. While the full medial axis captures every nuance of the boundary (including minor protrusions), the spine represents the "primary axis of symmetry" or the longest path through the object's main body.Topological Constraint: The spine must be a 1-manifold (a simple curve with no loops or branches) connecting two distinct endpoints.Geometric Constraint: The spine must be centered. In a binary shape, "centered" means equidistant from the boundaries. In a depth-augmented shape, "centered" implies following the "ridge" or the locus of maximum height.1Biological/Physical Analogy: Consider a physiological structure like a blood vessel or a biological organism like a nematode. The spine corresponds to the centerline of the tube. In these cases, the depth map (representing thickness or intensity) peaks at the center and falls off towards the edges. The problem of finding the spine is thus mathematically equivalent to extracting the "ridge" of a terrain or the "thalweg" of a river channel.31.2 The Failure of Local HeuristicsThe user's proposed methodology—starting at the boundary and climbing the depth gradient—falls into the category of "steepest ascent" or "hill climbing" algorithms. Such methods operate on local information: at any given pixel, the algorithm looks only at its immediate neighbors to decide the direction of movement.The Gradient Trap: Gradient ascent directs a path perpendicular to the contour lines of the depth map. For a tubular object, this direction points from the edge towards the center ridge. However, once the path reaches the ridge, the gradient along the ridge itself (the "longitudinal" gradient) is often near zero or fluctuates due to noise. A local gradient algorithm will stall at the first local peak it encounters, failing to traverse the length of the object to the "head" or "tip".1The Starting Point Problem: The proposal to start at "the boundary location with the lowest depth" is ambiguous. For a segmented object, the entire boundary boundary is typically at zero depth. Initiating a search from an arbitrary boundary point (e.g., the side of the object) does not guarantee that the path will orient itself along the longitudinal axis; it may simply cross the object transversely.1.3 The Global Geodesic AlternativeThe robust alternative treats the spine extraction not as a "climbing" problem but as a path planning problem. By defining a cost function that is inversely proportional to the depth (or medialness), the problem is transformed into finding the path of least resistance between the object's extremities.Global Optimality: Algorithms like Dijkstra or Fast Marching compute the accumulated cost of a path. Even if the ridge has local dips (saddle points), the algorithm "knows" that staying on the ridge is globally cheaper than taking a shortcut through the high-cost boundary regions.6Robust Endpoint Detection: Instead of arbitrary boundary points, the "tip" and "tail" are identified as the Geodesic Diameter of the shape—the pair of points that are furthest apart within the metric of the object.8This report details the implementation of this global framework, comparing it against alternative methods such as topological thinning and Hessian-based ridge detection, and providing a synthesized pipeline for Python-based implementation.2. Theoretical Framework: The Geometry of SkeletonsTo construct a robust solution, we must first dissect the mathematical definitions of "center" and "skeleton" in the context of 2D shapes and 2.5D height fields.2.1 The Medial Axis Transform (MAT)The classical definition of a skeleton for a 2D shape $\Omega$ is the Medial Axis Transform (MAT), introduced by Harry Blum in the 1960s using the "Grassfire Analogy." If a fire is ignited simultaneously along the entire boundary $\partial \Omega$ and propagates inward at a constant speed, the medial axis is the set of points where the fire fronts meet and extinguish each other.10Mathematically, the MAT is the locus of centers of maximal inscribed disks. A disk $B(x, r)$ is maximal if it is contained in $\Omega$ and not contained in any other disk $B' \subset \Omega$.$$MAT(\Omega) = \{ x \in \Omega : \exists y, z \in \partial \Omega, y \neq z, ||x-y|| = ||x-z|| = \min_{p \in \partial \Omega} ||x-p|| \}$$This definition implies that every point on the medial axis is equidistant to at least two points on the boundary. This equidistance property is crucial because it ensures the skeleton is geometrically centered.Limitations of MAT for Spine Extraction:While theoretically elegant, the MAT is unstable. A tiny perturbation on the boundary (a single pixel "bump") creates a new branch in the medial axis that extends to that bump. For a user seeking a single "spine" (a simple curve), the raw MAT is often a complex graph with hair-like spurs that requires aggressive pruning.6 Furthermore, the standard MAT relies solely on the binary boundary, completely ignoring the potentially rich information contained in the user's depth map.2.2 Ridge Detection in Scalar FieldsWhen a depth map $Z(x, y)$ is available, the problem can be reframed as Ridge Detection. A ridge is a curve on a surface where the surface is locally maximal in one direction (transverse to the ridge) and relatively flat in the orthogonal direction (along the ridge).Topographically, ridges are the "drainage divides" or the crests of hills. In differential geometry, ridges are defined using the Hessian Matrix of second-order derivatives:$$H(x, y) = \begin{bmatrix} \frac{\partial^2 Z}{\partial x^2} & \frac{\partial^2 Z}{\partial x \partial y} \\ \frac{\partial^2 Z}{\partial y \partial x} & \frac{\partial^2 Z}{\partial y^2} \end{bmatrix}$$The eigenvalues of the Hessian ($\lambda_1, \lambda_2$) characterize the local shape.Ridge Point: A point is on a ridge if the eigenvalue with the largest absolute magnitude ($\lambda_1$) is highly negative (indicating strong downward curvature) and the corresponding eigenvector is perpendicular to the ridge direction. The second eigenvalue ($\lambda_2$) should be close to zero (indicating low curvature along the ridge).13Steerable Filters and Hessian Limitations:Algorithms like Steger's Ridge Detector or Frangi Vesselness use these derivatives to highlight ridge-like structures.13 However, these are local detectors. They produce a "probability map" of ridgeness rather than a connected curve. Noise in the depth map can cause the ridge detector to produce broken segments, dashed lines, or parallel responses, failing to satisfy the user's requirement for a single connected spine connecting tip and tail.52.3 Distance Transforms vs. Depth MapsA critical insight is that for many objects, the Euclidean Distance Transform (EDT) is a synthetic depth map. The EDT assigns to each pixel its distance to the nearest boundary.For a perfect circle, the EDT is a cone.For a rectangle, the EDT resembles a tent or roof.The ridges of the EDT correspond exactly to the Medial Axis.10The user's Depth Map provides independent information.Case A (Correlation): If the object is a 3D cylinder projected onto 2D, the depth map and the EDT are perfectly correlated.Case B (Conflict): If the object is a "dumbbell" shape but the depth is uniform (flat top), the depth map has no ridge, but the EDT has a clear skeletal structure.Case C (Detail): If the object is a river channel, the boundary might be irregular (noisy EDT), but the depth map clearly shows the deep channel (clean thalweg).Conclusion: The most robust "medialness" function fuses both signals. We use the EDT to enforce geometric centering relative to the boundary, and the Depth Map to enforce topological centering relative to the object's volume.183. Critique of Gradient-Based HeuristicsThe user suggested: "Start at the boundary location with the lowest depth and use an A* algorithm to follow the highest depth gradient."This section formally analyzes why this heuristic is flawed and why global pathfinding is the necessary correction.3.1 The Failure of Local Gradient AscentGradient ascent moves a "walker" from pixel $x$ to the neighbor $x'$ that maximizes $Z(x') - Z(x)$.$$\Delta x = \alpha \nabla Z(x)$$This describes the path of "steepest ascent." While this will lead a walker from the valley floor to a peak, it does not necessarily follow the ridge.Trajectory: Steepest ascent paths are perpendicular to contour lines. On an elongated ellipsoid (like a cigar), the contour lines are ellipses. A path starting from the side will move perpendicular to the side, hitting the ridge at a 90-degree angle, and then stop (or jitter) because the gradient along the ridge is negligible compared to the gradient from the side.1Result: The algorithm finds a path from the boundary to the nearest point on the spine, not the path along the spine.3.2 The A* MisapplicationA* is a pathfinding algorithm designed to find the shortest path to a known goal node using a heuristic distance.Unknown Goal: The user's query implies the "Tip" and "Tail" are unknown. A* cannot function without a target. If the target is undefined, A* devolves into a Best-First Search or Flood Fill.Gradient as Cost: If the user attempts to define the cost of moving to a neighbor as inversely proportional to the gradient magnitude ($Cost \propto 1/|\nabla Z|$), the algorithm will prefer flat areas. This might inadvertently select the spine (which is locally flat along its axis), but it will also select any flat plateau or the background.20Gradient as Heuristic: If the user defines the cost as negative depth ($Cost \propto -Z$), A* essentially performs the gradient ascent described above, suffering from the same local maxima traps. If the object has two humps (a "B" shape), the path will get stuck at the first hump and never cross the saddle point to the second hump.33.3 Connectivity and TopologyA fundamental requirement of a "spine" is that it connects the two most extreme points of the shape (Tip and Tail) through the topological center. Gradient-based methods are exploratory: they trace a path until a stopping criterion (local maximum) is met. They do not ensure global connectivity.Scenario: A "U" shaped object.Gradient Failure: Starting at one tip of the "U", the gradient might lead up to a local peak in that arm. To get to the other arm, the path must go "downhill" through the curve of the U and then "uphill" again. Gradient ascent cannot go downhill. It will terminate halfway.Geodesic Success: A global pathfinding algorithm calculates the cost of the entire route. Even if the middle of the "U" is shallower (higher cost), it recognizes that traversing it is the only way to reach the destination, thus finding the correct curved spine.214. The Geodesic Metric FormulationThe "Correct Way" to solve the problem is to construct a Riemannian Manifold where the "spine" is the Geodesic (shortest path). This transforms the problem from heuristic tracing to global energy minimization.4.1 Constructing the Medialness Field ($M$)We first define a scalar field $M(x)$ that quantifies how "spine-like" a pixel is. High values indicate the center; low values indicate the boundary.To be robust, this field should fuse the boundary constraints (EDT) and the volumetric data (Depth).4.1.1 The Distance ComponentLet $B$ be the binary mask of the object. We compute the Euclidean Distance Transform:$$D_{edt}(x) = \min_{y \in \partial B} ||x - y||_2$$This ensures the spine stays away from jagged edges.4.1.2 The Depth ComponentLet $Z(x)$ be the raw depth map. We assume $Z(x)$ is higher in the center. If the depth map is noisy, it should be smoothed with a Gaussian kernel ($Z_{smooth} = Z * G_\sigma$) to prevent the spine from zig-zagging between pixel-level noise spikes.24.1.3 Fusion FormulaThe combined Medialness $M(x)$ is a weighted sum or product. A normalized sum is robust and commonly used in vascular extraction 18:$$M(x) = w_1 \cdot \frac{D_{edt}(x)}{\max(D_{edt})} + w_2 \cdot \frac{Z_{smooth}(x)}{\max(Z_{smooth})}$$$w_1, w_2$: Weights (e.g., 0.5, 0.5). If the boundary is very reliable, weight $D_{edt}$ higher. If the boundary is occluded but depth is clear, weight $Z$ higher.4.2 The Speed and Potential FunctionsPathfinding algorithms like Fast Marching solve the Eikonal equation:$$|\nabla T(x)| F(x) = 1$$or$$|\nabla T(x)| = P(x)$$where $T(x)$ is the arrival time, $F(x)$ is the Speed, and $P(x) = 1/F(x)$ is the Potential (or refractive index).To force the path to follow the ridge, the speed must be maximal (and potential minimal) at the ridge.The Exponential Potential:A highly effective formulation derived from "Minimum Cost Path" literature 6 is:$$P(x) = \exp(-\gamma \cdot M(x))$$$\gamma$ (Gamma): A contrast factor. A high $\gamma$ (e.g., 10) creates a "canyon" in the potential landscape along the spine. The pathfinding algorithm is strictly confined to this canyon because stepping out of it (into lower medialness) incurs a massive cost penalty.This formulation is superior to linear inversion ($1/M$) because it provides stronger gradients near the center, preventing "corner cutting" on curved shapes.4.3 The Riemannian MetricThis setup effectively defines a Riemannian metric tensor $g_{ij}$ over the 2D domain:$$ds^2 = P(x)^2 (dx^2 + dy^2)$$The length of a curve $\mathcal{C}$ is given by:$$L(\mathcal{C}) = \int_{\mathcal{C}} P(\mathcal{C}(t)) dt$$The spine is the curve $\mathcal{C}^*$ that minimizes this weighted length between the tip and tail.5. Automatic Endpoint Detection: The Tip and TailThe user's request requires the spine to connect "the tip and tail." In an arbitrary blob, these concepts correspond to the Geodesic Diameter of the shape. The Geodesic Diameter is the longest possible shortest path strictly contained within the domain.85.1 Euclidean vs. Geodesic DiameterEuclidean Diameter: The distance between the two farthest points in a straight line (convex hull diameter). This fails for non-convex shapes (e.g., a "C" shape or a snake), where the Euclidean line crosses the background.Geodesic Diameter: This measures distance along the manifold. For a "C" shape, the geodesic diameter correctly traces the curve from one tip to the other.5.2 The Double Sweep Algorithm (Heuristic)Computing the true diameter requires calculating the shortest path between all pairs of pixels ($O(N^2)$), which is computationally prohibitive for images. The Double Sweep Algorithm (or 2-Pass BFS) provides a highly accurate approximation in $O(N)$ time.9The Algorithm:Seed Initialization: Select an arbitrary valid point $p_{seed}$ inside the object. The centroid of the mask or the point of maximum depth are good choices.Sweep 1 (Outward): Compute the Geodesic Distance Map $D_1(x)$ from $p_{seed}$ to all other pixels $x \in \Omega$ using the potential $P(x)$.This map represents the cost to travel from the seed to any point.Identify Tip ($s$): The point with the maximum value in $D_1$ is the "Tip." Logic: The farthest point from any internal point is almost always one of the geodesic extremities.$$s = \arg \max_{x \in \Omega} D_1(x)$$Sweep 2 (Inward/Across): Compute a second Geodesic Distance Map $D_2(x)$ starting from the Tip $s$.Identify Tail ($t$): The point with the maximum value in $D_2$ is the "Tail."$$t = \arg \max_{x \in \Omega} D_2(x)$$Outcome: The pair $(s, t)$ represents the two most distant points on the weighted manifold. Because our metric $P(x)$ penalizes moving away from the center, these points will naturally settle at the ends of the object's main axis (the "tips" of the tube).6. Algorithmic Implementation: The "Correct" PipelineThis section synthesizes the theory into a concrete, implementable workflow.6.1 Requirements and Pre-processingInput: Binary Mask $B$ and Depth Map $Z$.Libraries: Python is the standard environment. Key libraries include scikit-fmm (for Fast Marching), skimage (for distance transforms), and numpy.6.2 Step-by-Step AlgorithmStep 1: Metric ConstructionDistance Transform: Compute $D_{edt} = \text{distance\_transform\_edt}(B)$.Smoothing: Apply Gaussian blur to $Z$ to reduce noise: $Z_{smooth} = \text{gaussian}(Z, \sigma=2)$.Normalization: Scale both $D_{edt}$ and $Z_{smooth}$ to the range $$.Medialness Fusion: Calculate $M = 0.5 \cdot D_{edt} + 0.5 \cdot Z_{smooth}$.Potential Map: Calculate $P = \exp(-10 \cdot M)$. Add a small epsilon to avoid math errors if needed. Mask the Potential Map so that pixels outside the object ($B=0$) have infinite cost (or are masked out).Step 2: Endpoint Detection (Double Sweep)Select Seed: Let $p_{start}$ be the pixel with the highest Medialness $M$ (guaranteed to be deep inside the object).First March: Use Fast Marching (skfmm.travel_time) to compute the travel time map $T_1$ from $p_{start}$ using speed $F = 1/P$.Find Tip: $s = \text{unravel\_index}(\text{argmax}(T_1 \cdot B))$. (Multiply by $B$ to ensure we only look inside the mask).Second March: Use Fast Marching to compute travel time map $T_2$ from $s$.Find Tail: $t = \text{unravel\_index}(\text{argmax}(T_2 \cdot B))$.Step 3: Spine Extraction (Back-Tracking)The map $T_2$ contains the geodesic distance from the Tip $s$ to every point.The spine is the Gradient Descent path from the Tail $t$ back to the Tip $s$ on the surface $T_2$.Start at $x = t$.Iteratively move to the neighbor with the lowest $T_2$ value.$$x_{next} = x_{current} - \eta \frac{\nabla T_2}{|\nabla T_2|}$$Stop when $T_2(x) \approx 0$ (reached the Tip).6.3 Table 1: Comparison of MethodologiesFeatureUser's Heuristic (Gradient Ascent)Binary Skeletonization (Thinning)Geodesic / Fast Marching (Proposed)Input DataDepth onlyBinary Mask onlyDepth + Binary MaskConnectivityBroken (Stops at local peaks)Guaranteed (Homotopy preserving)Guaranteed (Global path)RobustnessLow (Trapped by noise)Low (Sensitive to boundary bumps)High (Integral accumulation smooths noise)Topological CorrectnessIncorrect (Local greedy search)Correct (if pruned heavily)Correct (Finds global diameter)Result TypeDisconnected segmentsComplex graph (branches)Single simple curve (Spine)Computational CostLow ($O(N)$)Low ($O(N)$)Moderate ($O(N \log N)$)6.4 Python Implementation NotesThe scikit-fmm library is specifically designed for this.Pythonimport skfmm
import numpy as np
from skimage.morphology import medial_axis

#... (Assume 'speed' map is prepared as 1/Potential)...

# Create a masked array where the background is masked out
# This forces the Fast Marching wave to stay INSIDE the object.
masked_speed = np.ma.masked_array(speed, ~binary_mask)
phi = np.ma.masked_array(np.ones_like(binary_mask), ~binary_mask)

# Set the source point distance to 0
phi[start_point] = 0

# Run Fast Marching
travel_time = skfmm.travel_time(phi, masked_speed)
277. Alternative Approaches and Edge CasesWhile the Geodesic framework is the gold standard, it is worth acknowledging specific edge cases and alternative "hybrid" methods found in the literature.7.1 "FilFinder" and Graph PruningIn astronomy (extracting filaments from nebula images) and plant phenotyping (root systems), the problem is similar. Libraries like fil_finder 30 and PlantCV 32 use a hybrid approach:Thresholding: Adaptive thresholding of the image to get a mask.Medial Axis: Computing the standard binary skeleton.Graph Analysis: Converting the skeleton pixels into a graph (nodes and edges).Pruning: Identifying the "longest path" in the graph and pruning all shorter branches.Critique: This is a discrete approximation of the continuous geodesic method. It is faster but less precise. It discards the depth information during the skeletonization phase, only using it perhaps for thresholding. For the user's specific request (using depth map features), the continuous FMM approach is superior because it allows the depth to bend the spine towards the true center, whereas binary skeletonization is locked to the geometric center of the mask.7.2 Steger's Algorithm (Sub-pixel Ridges)For applications requiring extreme precision (sub-pixel accuracy), Steger's Ridge Detection is the standard.15 It analytically solves for the zero-crossing of the first derivative of the intensity (depth) profile.Utility: Excellent for industrial inspection (cracks) or laser striping.Drawback: It does not guarantee connectivity. It returns a set of "edgels" (edge pixels) that must be linked. The FMM approach inherently produces a connected chain.7.3 VMTK (Vascular Modeling Toolkit)In medical imaging, the vmtk library implements exactly the geodesic approach described here to extract centerlines of blood vessels. It computes Voronoi diagrams for the medial axis but uses the Eikonal equation (FMM) to weight the paths by vessel radius (analogous to depth).18 This validates the proposed method as the industry standard for "tubular" spine extraction.8. ConclusionTo find the "spine of the curve" connecting tip and tail using a depth map, one must abandon local heuristics in favor of global optimization. The user's intuition to use depth gradients is partially correct—depth is a proxy for medialness—but the mechanism of "following the gradient" is structurally flawed for global topological tasks.The Definitive Solution:Fuse the Euclidean Distance Transform (from the outline) and the Depth Map into a unified Speed Function where the center of the object is "fast" and the edges are "slow."Identify the Tip and Tail automatically using the Double Sweep Algorithm on the weighted geodesic manifold.Extract the spine by solving the Eikonal Equation (Fast Marching Method) to find the global minimum cost path between these endpoints.This approach transforms the depth map from a passive feature into an active metric, ensuring the resulting spine is mathematically guaranteed to be connected, centered, and representative of the object's global geometry. It serves as the robust, "correct" answer to the user's query, supported by extensive literature in computational geometry and image analysis.